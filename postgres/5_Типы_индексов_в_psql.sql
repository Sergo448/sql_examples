-- # **Типы индексов в PostgreSQL: полное руководство с примерами**

-- PostgreSQL предлагает богатый набор типов индексов, каждый из которых оптимизирован для конкретных сценариев использования.
-- В этой статье мы подробно разберём все доступные виды индексов, их внутреннее устройство и рекомендации по применению.

-- ## **1. B-tree (B-деревья) — стандартный индекс**

-- **Самый распространённый тип**, используемый по умолчанию при создании индекса.

-- ```sql
CREATE INDEX idx_users_email ON users(email);
-- ```

-- ### **Характеристики:**
-- - Оптимален для операций сравнения (`=`, `>`, `<`, `BETWEEN`)
-- - Поддерживает сортировку (`ORDER BY`)
-- - Эффективен для уникальных индексов
-- - Работает с `NULL` значениями (можно настроить)

-- ### **Когда использовать:**
-- - Поиск по точным значениям
-- - Диапазонные запросы
-- - Ускорение `ORDER BY` и `DISTINCT`

-- ## **2. Hash — индекс для точного совпадения**

-- Оптимизирован для операций **строгого равенства** (`=`).

-- ```sql
CREATE INDEX idx_users_id_hash ON users USING HASH(id);
-- ```

-- ### **Особенности:**
-- - Быстрее B-tree для операций `=`
-- - Не поддерживает диапазонные запросы
-- - Не используется в сортировке
-- - Требует ручного перестроения после сбоя (до PG 10)

-- ### **Применение:**
-- - Точечные запросы по первичному ключу
-- - Частые запросы вида `WHERE column = value`

-- ## **3. GiST (Generalized Search Tree) — индекс для сложных данных**

-- Универсальная инфраструктура для **разных типов данных**.

-- ```sql
CREATE INDEX idx_geo ON locations USING GIST(geom);
-- ```

-- ### **Поддерживаемые типы данных:**
-- - Геометрические объекты (PostGIS)
-- - Полнотекстовый поиск
-- - Диапазоны (`int4range`, `tsrange`)
-- - JSON/JSONB (через расширения)

-- ### **Примеры использования:**
-- - Поиск ближайших точек (KNN)
-- - Проверка пересечения геометрий
-- - Индексация IP-адресов

-- ## **4. GIN (Generalized Inverted Index) — для составных значений**

-- Оптимален для индексации **массивов, JSON и полнотекстового поиска**.

-- ```sql
CREATE INDEX idx_tags ON articles USING GIN(tags);
-- ```

-- ### **Ключевые особенности:**
-- - Эффективен для данных, содержащих **множество значений в одном поле**
-- - Поддерживает операторы: `@>`, `<@`, `&&`, `?` и др.
-- - Больше размер на диске, чем у GiST

-- ### **Основные сценарии:**
-- - Индексация массивов
-- - Работа с JSON/JSONB документами
-- - Ускорение полнотекстового поиска

-- ## **5. SP-GiST (Space-Partitioned GiST) — для неоднородных данных**

-- Оптимизирован для **пространственного разбиения** нерегулярных структур.

-- ```sql
CREATE INDEX idx_phone ON contacts USING SPGIST(phone_number);
-- ```

-- ### **Типичное применение:**
-- - Телефонные номера
-- - IP-адреса
-- - Геометрические данные с особым распределением

-- ## **6. BRIN (Block Range INdex) — для больших упорядоченных таблиц**

-- Эффективен для **очень больших таблиц с естественной сортировкой**.

-- ```sql
CREATE INDEX idx_logs_time ON logs USING BRIN(created_at);
-- ```

-- ### **Принцип работы:**
-- - Хранит диапазоны значений для блоков данных
-- - Крайне компактен (в сотни раз меньше B-tree)
-- - Требует, чтобы данные были отсортированы по индексируемому полю

-- ### **Идеальные случаи:**
-- - Логи временных рядов
-- - Данные датчиков с временными метками
-- - Большие неизменяемые таблицы

-- ## **7. Bloom — фильтр Блума для многоколоночных запросов**

-- Специализированный индекс для **множества столбцов**.

-- ```sql
CREATE INDEX idx_bloom ON orders USING BLOOM(status, client_id, date);
-- ```

-- ### **Особенности:**
-- - Компактный вероятностный индекс
-- - Может давать ложные срабатывания
-- - Эффективен для `WHERE col1 = A AND col2 = B AND ...`

-- ## **8. Частичные индексы (Partial indexes)**

-- Индексы, построенные **только для части данных**.

-- ```sql
CREATE INDEX idx_active_users ON users(email) WHERE is_active = true;
-- ```

-- ### **Преимущества:**
-- - Меньший размер
-- - Более высокая производительность
-- - Меньшие накладные расходы при записи

-- ## **9. Составные (многоколоночные) индексы**

-- Индексы по **нескольким столбцам**.

-- ```sql
CREATE INDEX idx_name_department ON employees(last_name, department_id);
-- ```

-- ### **Важные нюансы:**
-- - Порядок столбцов критически важен
-- - Работает для условий с левыми столбцами:
--   - `WHERE last_name = 'Smith'` — **использует индекс**
--   - `WHERE department_id = 10` — **не использует индекс**

-- ## **10. Индексы на выражения (Functional indexes)**

-- Индексация **результатов вычислений**.

-- ```sql
CREATE INDEX idx_lower_name ON users(LOWER(username));
-- ```

-- ### **Популярные сценарии:**
-- - Нормализация регистра
-- - Извлечение частей дат
-- - Математические преобразования

-- ## **Сравнение типов индексов**

-- | Тип индекса | Оптимальные операторы     | Размер        | Скорость записи | Специализация                 |
-- |-------------|---------------------------|---------------|-----------------|-------------------------------|
-- | B-tree      | `=`, `>`, `<`, `BETWEEN`  | Средний       | Средняя         | Универсальный                 |
-- | Hash        | `=`                       | Малый         | Высокая         | Точечные запросы              |
-- | GiST        | Разные (зависит от типа)  | Большой       | Низкая          | Геоданные, диапазоны          |
-- | GIN         | `@>`, `<@`, `?`           | Очень большой | Низкая          | Массивы, JSON, FTS            |
-- | SP-GiST     | Зависит от типа           | Средний       | Средняя         | IP-адреса, спец. структуры    |
-- | BRIN        | `=`, `>`, `<` (по блокам) | Очень малый   | Очень высокая   | Упорядоченные большие таблицы |
-- | Bloom       | Многоколоночные `=`       | Средний       | Средняя         | Фильтрация по многим столбцам |

-- ## **Практические рекомендации**

-- 1. **Не индексируйте всё подряд** — каждый индекс замедляет вставку/обновление
-- 2. **Используйте `EXPLAIN ANALYZE`** для проверки использования индексов
-- 3. **Мониторьте неиспользуемые индексы**:
--    ```sql
--    SELECT * FROM pg_stat_all_indexes WHERE idx_scan = 0;
--    ```
-- 4. **Для полнотекстового поиска** комбинируйте GIN с tsvector
-- 5. **Для геоданных** используйте GiST или SP-GiST (PostGIS)
-- 6. **Рассмотрите BRIN** для таблиц >100GB с временными метками

-- ## **Заключение**

-- PostgreSQL предлагает самый богатый набор типов индексов среди современных СУБД:

-- - **B-tree** — универсальный выбор для большинства случаев
-- - **GIN/GiST** — для специализированных типов данных
-- - **BRIN** — революционное решение для больших данных
-- - **Частичные/функциональные** индексы — для тонкой оптимизации

-- Правильный выбор типа индекса может ускорить запросы в **сотни раз**. 
-- Всегда анализируйте свои запросы с помощью `EXPLAIN` перед созданием индексов и помните, 
-- что иногда лучшая оптимизация — это изменение структуры запроса или данных.